<?php
/*
 * Plugin Name: W3TC Minify Helper
 * Description: record the sent order of the JavaScript files and use this to create a W3TC Minify configuration
 * Version: 1.1
 * Plugin URI: http://magentacuda.com/an-alternate-way-to-set-w3tc-minify-file-order/
 * Author: Magenta Cuda
 * Author URI: http://magentacuda.com
 *
 * Copyright (c) 2019 Magenta Cuda
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * The W3 Total Cache auto minify mode does not work on my web site. The problem
 * is the order of the JavaScript files using the auto minify mode is different
 * from the order without minification. This results in undefined JavaScript
 * function errors. W3TC has a help tool for manually setting the order of
 * JavaScript files. I think this tool is tiresome to use. I just want to have
 * the same order as without minification. So, I wrote this plugin to do this.
 * 
 * Every view of a web page sets the ordered list of JavaScript files of the
 * template of that web page. If this ordered list has changed a new W3TC
 * configuration file is generated by modifying the value of the field
 * 'minify.js.groups' of the current W3TC configuration to be compatible with
 * the new ordered list of JavaScript files for that template. This process is
 * cumulative so after viewing a representative web page for each template a
 * complete W3TC configuration file will be built. Further, if the ordered list
 * of JavaScript files for a template changes then this will also build a new
 * compatible W3TC configuration file. N.B. - W3TC assumes that the ordered list
 * of JavaScript files for a template is fixed. If your web pages are dynamically 
 * computing the JavaScript files and two different web pages using the same
 * template compute different lists of JavaScript files then W3TC cannot be used
 * to minify those JavaScript files.
 * 
 * If in response to a warning you select the 'do not minify' option for a template
 * then this plugin will permanently ignore that template. However, you can force
 * this plugin to re-process that template by adding the query parameter 
 * "mc_ignore_do_not_minify_flag=1" to the URL of any page using that template.
 * Then you will receive the warning again and you can then select the
 * 'safe to minify' option.
 * 
 * This generated JSON configuration file can be downloaded and further edited to
 * fine tune the minify process and imported back into W3TC. The download link is
 * on the "Installed Plugins" admin page after the "Deactivate" link. But, before
 * you import this new configuration file into W3TC, you should download the
 * current configuration of W3TC so that you can restore the current configuration
 * if the new configuration does not work. Also, before importing the new
 * configuration file into W3TC you should diff the new configuration file against
 * the current configuration file of W3TC to verify that the new configuration file
 * has no obvious errors. You should also verify that you have a complete
 * configuration by viewing the 'minify.js.groups' section and checking that there
 * is an entry for each of your templates. N.B. - W3TC "Minify mode" must be set to
 * "Manual" for W3TC to use the ordered list of JavaScript files generated by this
 * plugin. 
 *
 * The following WP-CLI commands will display the database data of this plugin:
 *
 *     php wp-cli.phar eval 'print_r(get_option("mc_alt_w3tc_minify"));'
 *     php wp-cli.phar eval 'print_r(get_option("mc_alt_w3tc_minify_log"));'
 *     php wp-cli.phar eval 'print_r(get_option("mc_alt_w3tc_minify_skipped"));'
 *     php wp-cli.phar eval 'print_r(get_option("mc_alt_w3tc_minify_theme_map"));'
 *     php wp-cli.phar eval 'print_r(get_option("mc_alt_w3tc_minify_miscellaneous"));'
 *     php wp-cli.phar eval 'print_r(get_transient("mc_alt_w3tc_minify"));'
 *     php wp-cli.phar eval 'print_r(json_decode(get_option("w3tc_minify"),true));' 
 *
 * The second command is useful in verifying that a view of a representative web
 * page has been done for each of your templates. The last command dumps W3TC's
 * map of minified files to their component files.
 *
 * AJAX actions have been abused to return complete HTML pages so you can dump this plugin's database, logs and notes by:
 *   
 *     http://localhost/wp-admin/admin-ajax.php?action=mc_alt_w3tc_minify_get_log
 *     http://localhost/wp-admin/admin-ajax.php?action=mc_alt_w3tc_minify_get_database
 *     http://localhost/wp-admin/admin-ajax.php?action=mc_alt_w3tc_minify_get_theme_map
 *     http://localhost/wp-admin/admin-ajax.php?action=mc_alt_w3tc_minify_get_the_diff&theme=ce894&basename=page
 *     http://localhost/wp-admin/admin-ajax.php?action=mc_alt_w3tc_minify_get_w3tc_minify_map
 *     http://localhost/wp-admin/admin-ajax.php?action=mc_alt_w3tc_minify_get_w3tc_minify_map&file=94796.js
 *
 * The following WP-CLI commands will access my monitor of W3TC's "minify auto js" feature:
 *
 *     php wp-cli.phar eval 'print_r( get_option( MC_Alt_W3TC_Minify::OPTION_MONITOR_MINIFY_AUTOJS ) );'
 *
 *     php wp-cli.phar eval 'MC_Alt_W3TC_Minify::set_monitor_minify_autojs_options( "FILTER::w3tc_process_content", TRUE );'
 *     php wp-cli.phar eval 'MC_Alt_W3TC_Minify::set_monitor_minify_autojs_options( "FILTER::w3tc_processed_content", TRUE );'
 *
 *     php wp-cli.phar eval 'MC_Alt_W3TC_Minify::set_monitor_minify_autojs_options( "FILTER::w3tc_minify_js_do_local_script_minification", TRUE );'
 *     php wp-cli.phar eval 'MC_Alt_W3TC_Minify::set_monitor_minify_autojs_options( "FILTER::w3tc_minify_js_do_tag_minification", TRUE );'
 *     php wp-cli.phar eval 'MC_Alt_W3TC_Minify::set_monitor_minify_autojs_options( "FILTER::w3tc_minify_js_do_flush_collected", TRUE );'
 *     php wp-cli.phar eval 'MC_Alt_W3TC_Minify::set_monitor_minify_autojs_options( "FILTER::w3tc_minify_js_step", TRUE );'
 *     php wp-cli.phar eval 'MC_Alt_W3TC_Minify::set_monitor_minify_autojs_options( "FILTER::w3tc_minify_js_step_script_to_embed", TRUE );'
 *
 *     php wp-cli.phar eval 'MC_Alt_W3TC_Minify::set_monitor_minify_autojs_options( "FILTER::w3tc_minify_urls_for_minification_to_minify_filename", TRUE );'
 *
 *     php wp-cli.phar eval 'MC_Alt_W3TC_Minify::set_monitor_minify_autojs_options( "ENABLED::mc_w3tcm_auto_minify", TRUE );'
 *
 * The following WP-CLI commands will clear the database data of this plugin:
 *
 *     php wp-cli.phar eval 'delete_transient("mc_alt_w3tc_minify");'
 *     php wp-cli.phar eval 'delete_option("mc_alt_w3tc_minify");'
 *     php wp-cli.phar eval 'delete_option("mc_alt_w3tc_minify_log");'
 *     php wp-cli.phar eval 'delete_option("mc_alt_w3tc_minify_skipped");'
 *     php wp-cli.phar eval 'delete_option("mc_alt_w3tc_minify_theme_map");'
 *     php wp-cli.phar eval 'delete_option("mc_alt_w3tc_minify_miscellaneous");'
 *     php wp-cli.phar eval 'unlink( MC_Alt_W3TC_Minify::OUTPUT_DIR . "/" . MC_Alt_W3TC_Minify::CONF_FILE_NAME );'
 */

define( 'MC_DEBUG', TRUE );   # TODO: set to FALSE for production

class MC_Alt_W3TC_Minify {
    const PLUGIN_NAME                  = 'W3TC Minify Helper';
    const OPTION_NAME                  = 'mc_alt_w3tc_minify';
    const OPTION_LOG_NAME              = 'mc_alt_w3tc_minify_log';
    const OPTION_SKIPPED_NAME          = 'mc_alt_w3tc_minify_skipped';
    const OPTION_THEME_MAP             = 'mc_alt_w3tc_minify_theme_map';
    const OPTION_USE_INCLUDE           = 'mc_alt_w3tc_minify_use_include';
    const OPTION_MISCELLANEOUS         = 'mc_alt_w3tc_minify_miscellaneous';
    const OPTION_MONITOR_MINIFY_AUTOJS = 'mc_alt_w3tc_minify_monitor_minify_autojs';
    const TRANSIENT_NAME               = 'mc_alt_w3tc_minify';
    const OUTPUT_DIR                   = WP_CONTENT_DIR . '/mc-w3tcm-output';
    const CONF_FILE_NAME               = 'mc_alt_w3tc_minify.json';
    const NOTICE_ID                    = 'mc_alt_w3tc_minify_notice_id';
    const TEMPLATE_WARNINGS            = 'TEMPLATE-WARNINGS';
    const DO_NOT_MINIFY                = 'DO-NOT-MINIFY';
    const OVERRIDE_DO_NOT_MINIFY       = 'mc_ignore_do_not_minify_flag';           # query parameter to ignore 'do not minify' flag
    const AJAX_RESET                   = 'mc_alt_w3tc_minify_reset';
    const AJAX_SET_TEMPLATE_SKIP       = 'mc_alt_w3tc_minify_set_template_skip';
    const AJAX_GET_THEME_MAP           = 'mc_alt_w3tc_minify_get_theme_map';
    const AJAX_GET_LOG                 = 'mc_alt_w3tc_minify_get_log';
    const AJAX_GET_MISC                = 'mc_alt_w3tc_minify_get_misc';
    const AJAX_GET_THE_DIFF            = 'mc_alt_w3tc_minify_get_the_diff';
    const AJAX_GET_DATABASE            = 'mc_alt_w3tc_minify_get_database';
    const AJAX_GET_MINIFY_MAP          = 'mc_alt_w3tc_minify_get_w3tc_minify_map';
    private static $theme              = NULL;   # MD5 of the current theme
    private static $basename           = NULL;   # the basename of the current template in the current theme
    private static $the_data           = NULL;   # the database of this plugin
    private static $files              = [
                                             'include'        => [ 'files' => [] ],
                                             'include-body'   => [ 'files' => [] ],
                                             'include-footer' => [ 'files' => [] ]
                                        ];
    # admin-bar.js is a problem because every time the logged in status changes the "Admin Bar" will be inserted
    # or removed causing admin-bar.js to be added or removed from the ordered list of JavaScript files. This will
    # trigger a rebuild of the W3TC configuration file. To solve this we will omit admin-bar.js from the ordered
    # list of JavaScript files. Other files that need to be omitted can be entered into $files_to_skip. "admin-bar.js"
    # is easy to handle since it has no dependencies. If you skip a file with dependencies you may also need to skip
    # the dependencies depending on whether or not the batch file is included before or after the skipped file. A
    # skipped file is emitted at its normal location. A "include" batch file is emitted just after the <head> tag,
    # a "include-body" batch file is emitted just after the <body> tag and a "include-footer" batch file is emitted
    # just before the </body> tag.
    private static $files_to_skip   = [
        '/wp-includes/js/admin-bar.js',
        '/wp-includes/js/admin-bar.min.js'
    ];
    # By default processing is skipped. The filter 'template_include' will conditionally enable processing.
    private static $skip              = TRUE;
    # $use_include sets whether to use 'include' or 'include-body' for header scripts
    private static $use_include       = FALSE;
    # The following variables are used to control my monitor of Minify_AutoJs.
    # $auto_minify === TRUE - replaces the minification of Minify_AutoJs - this should reduce the number of minified files.
    private static $auto_minify       = FALSE;
    # Since $files_to_minify of the class Minify_AutoJs is a private property we need a shadow of this property that we can modify.
    # PHP Fatal error:  Uncaught Error: Cannot access private property W3TC\Minify_AutoJs::$files_to_minify
    private static $files_to_minify   = [];
    # $minify_filename is the index into the array $minify_filenames which is saved in the option 'w3tc_minify'.
    private static $minify_filename   = NULL;
    public static function init() {
        if ( ! is_dir( self::OUTPUT_DIR ) || ! is_writable( self::OUTPUT_DIR ) ) {
            \W3TC\Util_File::mkdir( self::OUTPUT_DIR );
            if ( ! is_dir( self::OUTPUT_DIR ) || ! is_writable( self::OUTPUT_DIR ) ) {
                error_log( 'MC_Alt_W3TC_Minify: Cannot create directory ' . self::OUTPUT_DIR );
            }
        }
        # Get additional files to skip.
        $files_to_skip        = file( __DIR__ . '/files-to-omit.ini', FILE_IGNORE_NEW_LINES );
        $files_to_skip        = $files_to_skip === FALSE ? [] : $files_to_skip;
        $files_to_skip        = array_filter( $files_to_skip, function( $line ) {
            return $line[0] !== '#';
        } );
        $files_to_skip        = array_map( function( $file ) {
            return trim( $file );
        }, $files_to_skip );
        self::$files_to_skip  = array_merge( self::$files_to_skip, $files_to_skip );
        self::$use_include    = get_option( self::OPTION_USE_INCLUDE );
        $initial_template     = NULL;
        # Save the initial template so we can detect if the filter 'template_include' was used to change the template.
        add_filter( 'template_include', function( $template ) use ( &$initial_template ) {
            $initial_template = $template;
            return $template;
        }, 0, 1 );
        # The filter 'template_include' is used only for side effects.
        # It is used to set the current theme - self::$theme - and the current template - self::$basename.
        # It conditionally enables processing by setting self::$skip = FALSE which is by default set to TRUE.
        # It detects if the template was selected by the filter 'template_include'.
        add_filter( 'template_include', function( $template ) use ( &$initial_template ) {
            # self::$theme is a MD5 hash of the theme path, the template and the stylesheet. 
            self::$theme               = \W3TC\Util_Theme::get_theme_key( $map_theme_root = get_theme_root(), 
                                                                          $map_template   = get_template(),
                                                                          $map_stylesheet = get_stylesheet() );
            # Save the binding of the theme's MD5 hash to the theme path, the template and the stylesheet in the database. 
            $theme_map                 = get_option( self::OPTION_THEME_MAP, [] );
            $theme_map[ self::$theme ] = [
                'theme_root' => $map_theme_root,
                'template'   => $map_template,
                'stylesheet' => $map_stylesheet
            ];
            update_option( self::OPTION_THEME_MAP, $theme_map );
            self::$basename = basename( $template, '.php' );
            # If query parameter self::OVERRIDE_DO_NOT_MINIFY exists ignore the skip by 'do not minify' flag for the current template.
            if ( empty( $_REQUEST[ self::OVERRIDE_DO_NOT_MINIFY ] ) ) {
                # Check if 'do not minify' has been set for this template.
                $data = self::get_the_data();
                if ( array_key_exists( self::$theme, $data ) && array_key_exists( self::$basename, $data[ self::$theme ] ) ) {
                    if ( $data[ self::$theme ][ self::$basename ] === self::DO_NOT_MINIFY ) {
                        # self::$skip === TRUE so processing will be skipped.
                        return $template;
                    }
                }
            }
            # W3TC cannot handle templates included using the filter 'template_include' so log it and send an error notice.
            if ( $template !== $initial_template ) {
                self::set_database_to_skip_current_template( "Skipped because it is an override of $initial_template.", <<<EOD
: WARNING: Template "$template" cannot be minified because it was included using the filter 'template_include'
to override the template "$initial_template". W3TC cannot handle templates included using the filter 'template_include'.
EOD
                );
                # self::$skip === TRUE so processing will be skipped.
                // Uncomment the following to test templates loaded using the 'template_include' filter.
                // self::$skip = FALSE;
                return $template;
            }
            # If we get here then enable processing.
            self::$skip = FALSE;
            return $template;
        }, PHP_INT_MAX, 1 );   # add_filter( 'template_include', function( $template ) use ( &$initial_template ) {
        # When each HTML <script> tag for a JavaScript file is emitted add an entry to the ordered list of JavaScript
        # files for the current theme and template. In addition to emitting the <script> tag WordPress may prepend
        # 'localize','translation' and 'before' inline <script> elements and append an 'after' inline <script> element.
        # WordPress may also bracket the above with a conditional HTML comment. In W3TC 'manual minify' mode the 
        # 'additional' prepended, appended HTML elements will be emitted as usual but the <script> tag for the
        # JavaScript file will not be emitted. Instead the contents of that file will be combined with other JavaScript
        # files and that combined file will be emitted somewhere else. This can change the order of execution of the
        # JavaScript code which can cause fatal errors. (I think this is a serious flaw in the design of W3TC 'manual
        # minify' mode and alternate design can avoid this problem but currently I don't see how to incorporate it into
        # the W3TC framework.) The best we can do for now is issue warnings if the relative order of a JavaScript file
        # and its 'additional' inline <script> elements is changed and let the user choose not to minify the current
        # template. A script tag with all additional HTML elements would look like:
        #
        # <!--[if lt IE 9]>
        # <script type='text/javascript'>/* localize script */</script>
        # <![endif]-->
        # <!--[if lt IE 9]>
        # <script type='text/javascript'>/* translation script */</script>
        # <script type='text/javascript'>/* before script */</script>
        # <script type='text/javascript' src='http://url/of/the/file.js'></script>
        # <script type='text/javascript'>/* after script */</script>
        # <![endif]-->
        #
        add_filter( 'script_loader_tag', function( $tag, $handle, $src ) {
            if ( self::$skip ) {
                return $tag;
            }
            # Skip JavaScript files like admin-bar.js.
            foreach ( self::$files_to_skip as $file ) {
                if ( strpos( $src, $file ) !== FALSE ) {
                    return $tag;
                }
            }
            if ( doing_action( 'wp_print_footer_scripts' ) ) {
                self::$files['include-footer']['files'][] = $src;
            } else if ( doing_action( 'wp_head' ) ) {
                # check if there is a localize script for this script.
                if ( $localize_data = wp_scripts()->get_data( $handle, 'data' ) ) {
                    $has_localize_script = TRUE;
                    # error_log( "FILTER::script_loader_tag(): '$src' has a localize script." );
                }
                error_log( 'FILTER::script_loader_tag(): $tag=' . $tag );
                # Check if a conditional HTML comment exists.
                if ( preg_match( '#<!--(\[if\s.+\])>.+<!\[endif\]-->#s', $tag, $matches ) === 1 ) {
                    error_log( 'FILTER::script_loader_tag(): $matches=' . print_r( $matches, TRUE ) );
                    $has_conditional = TRUE;
                    $condition       = $matches[1];
                }
                # Check if there is a 'translation', 'before' or 'after' script for this script.
                if ( preg_match_all( '#<script.*?</script>#s', $tag, $matches,  PREG_SET_ORDER ) ) {
                    # error_log( 'FILTER::script_loader_tag(): $matches=' . print_r( $matches, TRUE ) );
                    foreach ( $matches as $index => $match ) {
                        if ( preg_match( '#\ssrc=(\'|").+?\1#', $match[0], $matches1 ) ) {
                            $src_index = $index;
                            # error_log( 'FILTER::script_loader_tag(): $src_index=' . $src_index );
                        } else {
                            if ( empty( $src_index ) ) {
                                $has_before_script = TRUE;
                                # error_log( "FILTER::script_loader_tag(): '$src' has a before script." );
                            } else {
                                $has_after_script  = TRUE;
                                # error_log( "FILTER::script_loader_tag(): '$src' has a after script." );
                            }
                        }
                    }
                }
                if ( self::$use_include ) {
                    # The problem with 'include' is the minified script file will be emitted immediately after
                    # the <head> tag and the inline scripts created wp_localize_script() will be emitted much
                    # later. However, WordPress normally emits the inline script created wp_localize_script()
                    # immediately before the script being localized.
                    self::$files['include']['files'][] = $src;
                } else {
                    # Using 'include-body' emits the minified script file after the <body> tag. Hence, the
                    # inline scripts created by wp_localize_script() which will be emitted in the <head>
                    # section will be emitted before the minified file.
                    self::$files['include-body']['files'][] = $src;
                }
                # Issue a warning if the script tag is bracketed by a HTML conditional comment.
                if ( ! empty( $has_conditional ) ) {
                    $notice_id = md5( self::$theme . self::$basename . $src . $condition );
                    $ajax_url  = admin_url( 'admin-ajax.php', 'relative' )
                                        . '?action='                  . self::AJAX_SET_TEMPLATE_SKIP 
                                        . '&theme='                   . self::$theme
                                        . '&basename='                . self::$basename
                                        . '&' . self::NOTICE_ID . '=' . $notice_id
                                        . '&_wpnonce='                . wp_create_nonce( self::AJAX_SET_TEMPLATE_SKIP );
                    # The action, theme and basename substring must match the regex
                    # '#(\?action=' . self::AJAX_SET_TEMPLATE_SKIP . '&theme=\w+&basename=\w+&)#'.
                    # error_log( 'FILTER::script_loader_tag(): $ajax_url=' . $ajax_url );
                    $theme     = self::$theme;
                    $basename  = self::$basename;
                    # Queue the template warning as these should only be emitted if the configuration actually changes.
                    self::manage_notice_queue( self::TEMPLATE_WARNINGS, 'add', self::PLUGIN_NAME . <<<EOD
: WARNING: In template "$theme.$basename" the script "$src" has a HTML conditional comment - "$condition".
An action is required to resolve this. Either
<a href="{$ajax_url}&skip=1">Do not minify this template.</a>
or
<a href="{$ajax_url}&skip=0">Safe to minify this template.</a>
EOD
                    );
                }
                # Localize, translation and before scripts should be emitted before their corresponding script.
                # After scripts should be emitted after their corresponding script. If this order is not preserved
                # issue a warning. Because the conditions have side effects the or must be a non short-circuit or.
                if ( self::non_short_circuit_or(
                    ( self::$use_include   && ! empty( $has_localize_script ) && ( $position = 'localize' ) && ( $order = 'after' ) ),
                    ( self::$use_include   && ! empty( $has_before_script )   && ( $position = 'before' )   && ( $order = 'after' ) ),
                    ( ! self::$use_include && ! empty( $has_after_script )    && ( $position = 'after' )    && ( $order = 'before' ) )
                ) ) {
                    $notice_id = md5( self::$theme . self::$basename . $src . $position . $order );
                    $ajax_url      = admin_url( 'admin-ajax.php', 'relative' )
                                         . '?action='                  . self::AJAX_SET_TEMPLATE_SKIP 
                                         . '&theme='                   . self::$theme
                                         . '&basename='                . self::$basename
                                         . '&' . self::NOTICE_ID . '=' . $notice_id
                                         . '&_wpnonce='                . wp_create_nonce( self::AJAX_SET_TEMPLATE_SKIP );
                    # The action, theme and basename substring must match the regex
                    # '#(\?action=' . self::AJAX_SET_TEMPLATE_SKIP . '&theme=\w+&basename=\w+&)#'.
                    $misc_ajax_url = admin_url( 'admin-ajax.php', 'relative' )
                                         . '?action='                  . self::AJAX_GET_MISC
                                         . '&key='                     . $notice_id;
                    # error_log( 'FILTER::script_loader_tag(): $ajax_url=' . $ajax_url );
                    $theme     = self::$theme;
                    $basename  = self::$basename;
                    # Queue the template warning as these should only be emitted if the configuration actually changes.
                    self::manage_notice_queue( self::TEMPLATE_WARNINGS, 'add', self::PLUGIN_NAME . <<<EOD
: WARNING: In template "$theme.$basename" the script "$src" has a <a href="{$misc_ajax_url}" target="_blank">$position</a>
script which will be emitted $order itself. An action is required to resolve this. Either
<a href="{$ajax_url}&skip=1">Do not minify this template.</a>
or
<a href="{$ajax_url}&skip=0">Safe to minify this template.</a>
EOD
                    );
                    if ( $position === 'localize' ) {
                        self::add_miscellaneous( $notice_id, $localize_data );
                    }
                    if ( $position === 'before' || $position === 'after' ) {
                        self::add_miscellaneous( $notice_id, $tag );
                    }
                }
            }
            return $tag;
        }, 10, 3 );   # add_filter( 'script_loader_tag', function( $tag, $handle, $src ) {
        # On shutdown update the ordered list of Javascript files for the current theme and template if it is
        # different from its previous value and rebuild the W3TC configuration file if neccessary.
        add_action( 'shutdown', function() {
            if ( ! self::$skip ) {
                self::update_database();            
            }
        } );
        self::delete_old_miscellaneous( 86400 * 10 );
        self::monitor_minify_autojs();
    }   # public static function init() {
    public static function admin_init() {
        # This plugin doesn't require much user interactivity so it doesn't have a GUI.
        # Rather some non standard plugin action links are provided.
        add_filter( 'plugin_action_links_' . plugin_basename( __FILE__ ), function( $links ) {
            if ( file_exists( self::OUTPUT_DIR . '/' . self::CONF_FILE_NAME ) ) {
                # Add the download link for the generated conf file after the "Deactivate" link.
                array_push( $links,
                    '<a href="' . WP_CONTENT_URL . '/w3tc-config/' . self::CONF_FILE_NAME
                        . '">Download New W3TC Conf File</a>'
                );
            }
            # Let the user remove everything created by this plugin by AJAX request.
            # This AJAX request is sent to admin-ajax.php not as XHR but as a normal HTTP request
            # and will require special handling in the AJAX handler to return a HTML page.
            array_push( $links,
                '<a href="' . admin_url( 'admin-ajax.php', 'relative' ) . '?action=' . self::AJAX_RESET
                    . '&_wpnonce=' . wp_create_nonce( self::AJAX_RESET ) . '" title="Clear the database.">Reset</a>'
            );
            # Another abusive use of AJAX (sent as a normal HTTP request not as XHR) to dump the log in a web page.
            array_push( $links,
                '<a href="' . admin_url( 'admin-ajax.php', 'relative' ) . '?action=' . self::AJAX_GET_LOG
                    . '" title="Dump actions on templates in themes." target="_blank">Dump Log</a>'
            );
            return $links;
        } );
        # If the minify JavaScript configuration has changed display an admin notice.
        if ( is_admin() && ! wp_doing_ajax() && ( $notices = get_transient( self::TRANSIENT_NAME ) ) ) {
            # Some action notices may have expired nonces so renew those nonces.
            $set_template_skip_nonce = wp_create_nonce( self::AJAX_SET_TEMPLATE_SKIP );
            $notices = array_map( function( $notice ) use ( $set_template_skip_nonce ) {
                if ( strpos( $notice, 'action=' . self::AJAX_SET_TEMPLATE_SKIP . '&' ) !== FALSE ) {
                    return preg_replace( '#&_wpnonce=[a-f0-9]+&#', "&_wpnonce={$set_template_skip_nonce}&", $notice );
                } else {
                    return $notice;
                }
            }, $notices );
            $url = WP_CONTENT_URL . '/w3tc-config/' . self::CONF_FILE_NAME;
            add_action( 'admin_notices', function() use ( $notices, $url ) {
?>
<div class="notice notice-info is-dismissible">
<?php
                echo implode( '<br>', $notices );
                if ( array_reduce( $notices, function( $or, $notice ) {
                    return $or | strpos( $notice, 'updated' ) !== FALSE;
                }, FALSE ) ) {
?>
    <br><?php echo self::PLUGIN_NAME; ?>: The new configuration file can be downloaded from
        <a href="<?php echo $url; ?>"><?php echo $url; ?></a>.
<?php
                }
?>
</div>
<?php
            } );
            # Preserve notices that have a notice id as these require that an action be taken.
            $notices = array_filter( $notices, function( $notice ) {
                return strpos( $notice, self::NOTICE_ID ) !== FALSE;
            } );
            delete_transient( self::TRANSIENT_NAME );
            if ( $notices ) {
                set_transient( self::TRANSIENT_NAME, $notices );
            }
        }
        # Let the user remove everything created by this plugin by AJAX request.
        # N.B. This AJAX request was not sent by XHR but as a normal HTTP request
        # and will require special handling as a page needs to be returned.
        add_action( 'wp_ajax_' . self::AJAX_RESET, function() {
            check_ajax_referer( self::AJAX_RESET );
            self::reset();
            self::add_notice( self::PLUGIN_NAME .': The database has been cleared.' );
            # Since this AJAX request was not invoked as XHR but as a normal HTTP request
            # we need to redirect to return a page otherwise the browser will not have content.
            wp_redirect( admin_url( 'plugins.php' ) );
            exit();
        } );
        add_action( 'wp_ajax_' . self::AJAX_SET_TEMPLATE_SKIP, function() {
            # error_log( 'ACTION::wp_ajax_' . self::AJAX_SET_TEMPLATE_SKIP . '():$_REQUEST=' . print_r( $_REQUEST, true ) );
            check_ajax_referer( self::AJAX_SET_TEMPLATE_SKIP );
            if ( ! empty( $_REQUEST['skip'] ) ) {
                # Restore the minify helper environment of the referring page.
                self::set_current_template( $_REQUEST['theme'], $_REQUEST['basename'] );
                self::set_database_to_skip_current_template(
                    "Skipped because a script has an out of order localize, translation, before or after script.",
                    ": The scripts of template \"{$_REQUEST['theme']}.{$_REQUEST['basename']}\" will not be minified."
                );
                # Update the database and rebuild the W3TC configuration file.
                self::$files = self::DO_NOT_MINIFY;
                self::update_database();
            } else {
                self::add_notice( self::PLUGIN_NAME
                    . ": The scrips of template \"{$_REQUEST['theme']}.{$_REQUEST['basename']}\" will be minified." );
            }
            # Remove the corresponding transient notice. 
            $notice_id = $_REQUEST[ self::NOTICE_ID ];
            $notices   = get_transient( self::TRANSIENT_NAME );
            $match     = NULL;
            foreach ( $notices as $i => $notice ) {
                if ( strpos( $notice, $notice_id ) !== FALSE ) {
                    # Extract the action, theme and basename substring.
                    if ( preg_match( '#(\?action=' . self::AJAX_SET_TEMPLATE_SKIP . '&theme=\w+&basename=\w+&)#', $notice, $matches ) === 1 ) {
                        $match = $matches[0];
                        error_log( 'ACTION::wp_ajax_' . self::AJAX_SET_TEMPLATE_SKIP .'():$match="' . $match . '"' );
                    } else {
                        # This is an error as the action, theme and basename substring must exists.
                        error_log( self::PLUGIN_NAME . ': Error 1' );
                    }
                    unset( $notices[ $i ] );
                    break;
                }
            }
            # Remove other notices for the same action, theme and basename as these notices are now invalid.
            if ( $match !== NULL ) {
                foreach ( $notices as $i => $notice ) {
                    if ( strpos( $notice, $match ) !== FALSE ) {
                        unset( $notices[ $i ] );
                    }
                }
            }
            delete_transient( self::TRANSIENT_NAME );
            if ( $notices ) {
                set_transient( self::TRANSIENT_NAME, $notices );
            }
            wp_redirect( $_SERVER['HTTP_REFERER'] );
            exit();
        } );
        # a quick hack to dump the theme map abusing wordpress AJAX
        add_action( 'wp_ajax_' . self::AJAX_GET_THEME_MAP, function() {
?>
<html>
<body><pre>
<?php
    print_r( get_option( self::OPTION_THEME_MAP, [] ) );
?>
</pre></body>
</html>
<?php
            exit();
        } );
        # a quick hack to dump the log abusing wordpress AJAX
        add_action( 'wp_ajax_' . self::AJAX_GET_LOG, function() {
?>
<html>
<body><pre>
<?php
    print_r( get_option( self::OPTION_LOG_NAME, [] ) );
?>
</pre></body>
</html>
<?php
            exit();
        } );
        # a quick hack to dump the note by key from miscellaneous abusing wordpress AJAX.
        add_action( 'wp_ajax_' . self::AJAX_GET_MISC, function() {
            $buffer = '';
            if ( ! empty( $_REQUEST['key'] ) ) {
                foreach ( self::get_miscellaneous( $_REQUEST['key'] ) as $note ) {
                    if ( $buffer ) {
                        $buffer .= '<hr>';
                    }
                    $buffer .= htmlspecialchars( $note, ENT_NOQUOTES );
                }
            } else {
                $buffer = 'Error: Action "' . self::AJAX_GET_MISC . '" requires query parameter "key".';
            }
?>
<html>
<body><pre>
<?php echo $buffer; ?>
</pre></body>
</html>
<?php
            exit();
        } );
        # a quick hack to dump the latest diff for a template abusing wordpress AJAX.
        add_action( 'wp_ajax_' . self::AJAX_GET_THE_DIFF, function() {
            if ( isset( $_REQUEST['theme'], $_REQUEST['basename'] ) ) {
                $diff = self::get_the_latest_diff( $_REQUEST['theme'], $_REQUEST['basename'] );
            } else {
                $diff = 'Error: Action "' . self::AJAX_GET_THE_DIFF . '" requires query parameters "theme" and "basename".';
            }
?>
<html>
<body><pre>
<?php print_r( $diff ); ?>
</pre></body>
</html>
<?php
            exit();
        } );
        # a quick hack to dump the database abusing wordpress AJAX.
        add_action( 'wp_ajax_' . self::AJAX_GET_DATABASE, function() {
?>
<html>
<body><pre>
<?php print_r( get_option( 'mc_alt_w3tc_minify' ) ); ?>
</pre></body>
</html>
<?php
            exit();
        } );
        # a quick hack to dump W3TC's map of minified files to their component files.
        add_action( 'wp_ajax_' . self::AJAX_GET_MINIFY_MAP, function() {
?>
<html>
<body><pre>
<?php
    if ( ! empty( $_REQUEST['file'] ) ) {
        print_r( json_decode( get_option( 'w3tc_minify', [] ), TRUE )[ $_REQUEST['file'] ] );
    } else {
        print_r( json_decode( get_option( 'w3tc_minify', [] ), TRUE ) );
    }
?>
</pre></body>
</html>
<?php
            exit();
        } );
        # Make no_priv versions of above AJAX actions.
        foreach ( [ self::AJAX_GET_THEME_MAP, self::AJAX_GET_LOG, self::AJAX_GET_THE_DIFF, self::AJAX_GET_DATABASE,
            self::AJAX_GET_MINIFY_MAP ] as $ajax_action ) {
            add_action( 'wp_ajax_nopriv_' . $ajax_action, function() use ( $ajax_action ) {
                do_action( "wp_ajax_{$ajax_action}" );
            } );
        }
        # On deactivation remove everything created by this plugin. 
        register_deactivation_hook( __FILE__, function() {
            self::reset();
        } );
    }   # public static function admin_init() {
    # reset() will remove everything created by this plugin.
    private static function reset() {
        delete_transient( self::TRANSIENT_NAME );
        delete_option( self::OPTION_NAME );
        delete_option( self::OPTION_LOG_NAME );
        delete_option( self::OPTION_SKIPPED_NAME );
        delete_option( self::OPTION_THEME_MAP );
        delete_option( self::OPTION_MISCELLANEOUS );
        @unlink( self::OUTPUT_DIR . '/' . self::CONF_FILE_NAME );
    }
    private static function get_the_data() {
        if ( self::$the_data === NULL ) {
            self::$the_data = get_option( self::OPTION_NAME, [] );
        }
        return self::$the_data;
    }
    # Update the ordered list of Javascript files for the current theme and template if it is
    # different from its previous value and rebuild the W3TC configuration file if neccessary.
    private static function update_database() {
        # The option value is a two dimensional array indexed first by theme then by template.
        # The array values are arrays of JavaScript file names.
        # Deleting this option will force a rebuild of W3TC configuration file.
        # However, this will require again viewing a web page for all templates.
        $data = self::get_the_data();
        if ( ! array_key_exists( self::$theme, $data ) ) {
            $data[ self::$theme ] = [];
        }
        if ( ! array_key_exists( self::$basename, $data[ self::$theme ] ) ) {
            $data[ self::$theme ][ self::$basename ] = [
                                                           'include'        => [ 'files' => [] ],
                                                           'include-body'   => [ 'files' => [] ],
                                                           'include-footer' => [ 'files' => [] ]
                                                       ];
        }
        # Check if the ordered JavaScript file list has changed for the current theme and template.
        $datum =& $data[ self::$theme ][ self::$basename ];
        if ( ( ! empty( $_REQUEST[ self::OVERRIDE_DO_NOT_MINIFY ] ) || $datum !== self::DO_NOT_MINIFY )
            && self::$files !== $datum ) {
            # First flush the queued template warnings.
            self::manage_notice_queue( self::TEMPLATE_WARNINGS, 'flush' );
            # Record exactly how the new configuration differs from the previous configuration.
            self::log_the_diff( self::$files, $datum );
            # Update the array item for the current theme and template.
            if ( self::$files !== self::DO_NOT_MINIFY ) {
                $datum = self::$files;
            } else {
                # unset( $data[ self::$theme ][ self::$basename ] );
                # if ( empty( $data[ self::$theme ] ) ) {
                #     unset( $data[ self::$theme ] );
                # }
                # The above will not work as missing item will be interpreted as an uninitialized item.
                $datum = self::$files;
            }
            # error_log( 'ACTION::shutdown():MC_Alt_W3TC_Minify::new $data=' . print_r( $data, TRUE ) );
            # The minify JavaScript configuration has changed so save the new configuration into the database.
            update_option( self::OPTION_NAME, $data );
            # Then generate a new W3TC configuration file using the new data.
            self::update_config_file( $data );
            # Update the history of changes to the ordered list of Javascript files for themes and templates.
            self::add_log_entry( ! empty( self::$files ) ? 'Updated.' : 'Removed.' );
            # Create or update the transient notices. 
            self::add_notice( self::PLUGIN_NAME
                                 . ': The ordered list of JavaScript files for the theme: "'
                                 . '<a href="' . admin_url( 'admin-ajax.php', 'relative' ) . '?action='
                                 .     self::AJAX_GET_THEME_MAP . '" target="_blank">' . self::$theme . '</a>'
                                 . '" and the template: "' . self::$basename . '" has been '
                                 . '<a href="' . admin_url( 'admin-ajax.php', 'relative' ) . '?action='
                                 .     self::AJAX_GET_THE_DIFF . '&theme=' . self::$theme . '&basename='
                                 .     self::$basename . '" target="_blank">updated</a>.' );
        } else {
        }
    }   # private static function update_database() {
    private static function update_config_file( $new_data ) {
        $config = \W3TC\Config::util_array_from_storage( 0, FALSE );
        # error_log( 'MC_Alt_W3TC_Minify::update_config_file():old $config=' . print_r( $config, TRUE ) );
        $config_minify_js_groups =& $config['minify.js.groups'];
        foreach ( $new_data as $theme => $data ) {
            if ( array_key_exists( $theme, $config_minify_js_groups ) ) {
                # Replace matching template items for this theme.
                $config_minify_js_groups[ $theme ] = array_merge( $config_minify_js_groups[ $theme ], $data );
            } else {
                $config_minify_js_groups[ $theme ] = $data;
            }
        }
        # Remove DO_NOT_MINIFY items from $config['minify.js.groups'] before saving new config file;
        foreach ( $config_minify_js_groups as &$theme ) {
            $theme = array_filter( $theme, function( $template ) {
                return $template !== self::DO_NOT_MINIFY;
            } );
        }
        $config_minify_js_groups = array_filter( $config_minify_js_groups, function( $theme ) {
            return $theme;
        } );
        # error_log( 'MC_Alt_W3TC_Minify::update_config_file():new $config=' . print_r( $config, TRUE ) );
        # Save the new configuration to a disk file which can be downloaded.
        if ( defined( 'JSON_PRETTY_PRINT' ) ) {
            $config = json_encode( $config, JSON_PRETTY_PRINT );
        } else {  // for older php versions
            $config = json_encode( $config );
        }
        \W3TC\Util_File::file_put_contents_atomic( self::OUTPUT_DIR . '/' . self::CONF_FILE_NAME, $config );
    }   # private static function update_config_file( $new_data ) {
    private static function set_database_to_skip_current_template( $log_entry = '', $notice = '' ) {
        $skipped = get_option( self::OPTION_SKIPPED_NAME, [] );
        if ( ! array_key_exists( self::$theme, $skipped ) ) {
            $skipped[ self::$theme ] = [];
        }
        if ( ! in_array( self::$basename, $skipped[ self::$theme ] ) ) {
            if ( $log_entry ) {
                self::add_log_entry( $log_entry );
            }
            if ( $notice ) {
                self::add_notice( self::PLUGIN_NAME . $notice );
            }
            $skipped[ self::$theme ][] = self::$basename;
            update_option( self::OPTION_SKIPPED_NAME, $skipped );
        }
    }
    # log_the_diff() compute exactly how the new conf differs from the old conf and saves the diff to the log.
    private static function log_the_diff( $new, $old ) {
        if ( $new === self::DO_NOT_MINIFY || $old === self::DO_NOT_MINIFY ) {
            return;
        }
        $diff = new stdClass(); 
        foreach ( [ 'include', 'include-body', 'include-footer' ] as $location ) {
            $diff->{$location}          = new stdClass();
            $diff->{$location}->added   = array_diff( $new[ $location ]['files'], $old[ $location ]['files'] );
            $diff->{$location}->removed = array_diff( $old[ $location ]['files'], $new[ $location ]['files'] );
        }
        self::add_log_entry( $diff );
    }
    # get_the_latest_diff() finds the most recent diff for the template $basename of $theme.
    private static function get_the_latest_diff( $theme, $basename ) {
        $log = get_option( self::OPTION_LOG_NAME, [] );
        if ( ! array_key_exists( $theme, $log ) ) {
            return NULL;
        }
        if ( ! array_key_exists( $basename, $log[ $theme ] ) ) {
            return NULL;
        }
        $data = $log[ $theme ][ $basename ];
        for ( end( $data ); ; prev( $data ) ) {
            if ( ( $datum = current( $data )->data ) === FALSE ) {
                return NULL;
            }
            if ( is_object( $datum ) && property_exists( $datum, 'include' )
                && is_object( $datum->include ) && property_exists( $datum->include, 'added' ) ) {
                return $datum;
            }
        }
        return NULL;
    }
    # In a non-frontend environment (AJAX) the current template must be manually set.
    private static function set_current_template( $theme, $basename ) {
        self::$theme    = $theme;
        self::$basename = $basename;
    }
    private static function add_log_entry( $entry ) {
        $log = get_option( self::OPTION_LOG_NAME, [] );
        if ( ! array_key_exists( self::$theme, $log ) ) {
            $log[ self::$theme ] = [];
        }
        if ( ! array_key_exists( self::$basename, $log[ self::$theme ] ) ) {
            $log[ self::$theme ][ self::$basename ] = [];
        }
        $log[ self::$theme ][ self::$basename ][] = (object) [ 'time' => current_time( 'mysql' ), 'data' => $entry ];
        update_option( self::OPTION_LOG_NAME, $log );
    }
    private static function add_notice( $notice ) {
        $notices = get_transient( self::TRANSIENT_NAME );
        if ( $notices === FALSE ) {
            $notices = [ $notice ];
        } else {
            $notices[] = $notice;
        }
        set_transient( self::TRANSIENT_NAME, $notices );
    }
    # Some notices should only be added only if a later condition is true.
    # These notices are held in a temporary queue and will be added later if the required condition is true.
    private static function manage_notice_queue( $queue, $action, $notice = NULL ) {
        static $data = [];
        switch ( $action ) {
        case 'add':
            if ( ! array_key_exists( $queue, $data ) ) {
                $data[ $queue ]   = [ $notice ];
            } else {
                $data[ $queue ][] = $notice;
            }
            break;
        case 'flush':
            if ( ! empty( $data[ $queue ] ) ) {
                foreach ( $data[ $queue ] as $notice ) {
                    self::add_notice( $notice );
                }
            }
        case 'empty':
            unset( $data[ $queue ] );
            break;
        }
    }
    # Miscellaneous is currently used to hold meta data for notices using the notice id as the key.
    private static function add_miscellaneous( $key, $note ) {
        $notes = get_option( self::OPTION_MISCELLANEOUS, [] );
        # There may be multiple notes for a given key so $notes[ $key ] is an array.
        if ( ! array_key_exists( $key, $notes ) ) {
            $notes[ $key ] = [];
        }
        $notes[ $key ][] = [
                               'time' => time(),
                               'data' => $note
        ];
        update_option( self::OPTION_MISCELLANEOUS, $notes );
    }
    private static function get_miscellaneous( $key ) {
        $notes = get_option( self::OPTION_MISCELLANEOUS, [] );
        # Extract only the 'data' component before returning.
        return array_key_exists( $key, $notes ) ? array_map( function( $data ) {
            return $data['data'];
        }, $notes[ $key ] ) : [];
    }
    private static function delete_miscellaneous( $key ) {
        $notes = get_option( self::OPTION_MISCELLANEOUS, [] );
        unset( $notes[ $key ] );
        update_option( self::OPTION_MISCELLANEOUS, $notes );
    }
    private static function delete_old_miscellaneous( $limit = 86400 * 10 ) {
        $notes = get_option( self::OPTION_MISCELLANEOUS, [] );
        $now   = time();
        $notes = array_filter( array_map( function( $data ) use ( $now, $limit ) {
            return array_filter( $data, function( $value ) use ( $now, $limit ) {
                return $now - $value['time'] < $limit;
            } );
        }, $notes ) );
        update_option( self::OPTION_MISCELLANEOUS, $notes );
    }
    public static function minify( $sources ) {
        static $w3_minifier = NULL;
        if ( $w3_minifier === NULL ) {
            $w3_minifier = \W3TC\Dispatcher::component( 'Minify_ContentMinifier' );
        }
        if ( ! is_object( $w3_minifier ) ) {
            return NULL;
        }
        if ( ! is_array( $sources ) ) {
            $sources = [ $sources ];
        }
        # Get the default JavaScript minifier used by Minify0_Minify::serve() -> Minify0_Minify::_combineMinify() in Minify.php.
        # This minifier is not applied to already minified files - ".min.js" files.
        // $js_minifier = $w3_minifier->get_minifier( 'combinejs' );
        $js_minifier = $w3_minifier->get_minifier( 'js' );
        $js_options  = $w3_minifier->get_options( 'js' );
        error_log( '$js_minifier=' . print_r( $js_minifier, true ) );
        error_log( '$js_options=' . print_r( $js_options, true ) );
        $cache_id        = md5( serialize( [ $sources, $js_minifier, $js_options ] ) );
        # Minify_Core::urls_for_minification_to_minify_filename() actually uses substr( $cache_id, 0, 5 ).
        # But it also has a collision protection safeguard which I don't want to implement so I use the full md5.
        $cache_id       .= '.js';
        $original_length = 0;
        $content         = [];
        foreach ( $sources as $source ) {
            $original_length += strlen( $source );
            $content[]        = call_user_func( $js_minifier, $source, $js_options );
        }
        $content         = implode( "\n;", $content );
        $minify          = \W3TC\Dispatcher::component( 'Minify_MinifiedFileRequestHandler' );
        $cache           = $minify->_get_cache();
        $cache->store( $cache_id, [ 'originalLength' => $original_length, 'content' => $content ] );
        # TODO: The compression logic should be determined from Minify0_Minify::$_options['encodeMethod'],
        # Minify0_Minify::$_options['encodeOutput'], ... But I don't see how to access Minify0_Minify::$_options.
        # So for now just hardcode gzip.
        if ( function_exists( 'gzencode' ) ) {
            $compressed = gzencode( $content, 9 );
            $cache->store( $cache_id . '_gzip', [ 'originalLength' => $original_length, 'content' => $compressed ] );
        }
        return [
            'original_length' => $original_length,
            'content'         => $content,
            'cache_id'        => $cache_id
        ];
    }
    # monitor_minify_autojs() can analyze the processing of Minify_AutoJs.php.
    # monitor_minify_autojs() optionally can replace the minify processing of Minify_AutoJs.php.
    public static function monitor_minify_autojs() {
        if ( ! ( $options = get_option( self::OPTION_MONITOR_MINIFY_AUTOJS, [] ) ) ) {
            return;
        }
        self::$auto_minify = ! empty( $options['ENABLED::mc_w3tcm_auto_minify'] );
        if ( ! empty( $options['FILTER::w3tc_process_content'] ) ) {
            add_filter( 'w3tc_process_content', function( $buffer ) {
                \W3TC\Util_File::file_put_contents_atomic( self::OUTPUT_DIR . '/filter_w3tc_process_content_buffer', $buffer );
            } );
        }
        if ( ! empty( $options['FILTER::w3tc_processed_content'] ) ) {
            add_filter( 'w3tc_processed_content', function( $buffer ) {
                \W3TC\Util_File::file_put_contents_atomic( self::OUTPUT_DIR . '/filter_w3tc_processed_content_buffer', $buffer );
            } );
        }
        if ( self::non_short_circuit_or( self::$auto_minify,
                $monitor = ! empty( $options['FILTER::w3tc_minify_js_do_local_script_minification'] ) ) ) {
            add_filter( 'w3tc_minify_js_do_local_script_minification', function( $data ) use ( $monitor ) {
                # This is an inline <script> element.
                if ( $monitor ) {
                    error_log( 'FILTER::w3tc_minify_js_do_local_script_minification():' );
                    self::print_r( $data, '$data' );
                    self::print_r( $data['script_tag_original'], '$data["script_tag_original"]' );
                }
                if ( self::$auto_minify && strpos( ( $script_tag = $data['script_tag_original'] ), '</head>' ) === FALSE ) {
                    # Collect this inline <script> element.
                    $script_tag_number = $data['script_tag_number'];
                    # Remove the HTML start and end tags from $script_tag.
                    $content           = preg_replace( '#</?script(\s.*?>|>)#', '', $script_tag );
                    # Save the content of the inline <script> element in a file.
                    $filename          = self::OUTPUT_DIR . '/' . 'mc-w3tcm-inline-' . $script_tag_number . '-' . md5( $content ) . '.js';
                    \W3TC\Util_File::file_put_contents_atomic( $filename, $content );
                    # PHP Fatal error:  Uncaught Error: Cannot access private property W3TC\Minify_AutoJs::$files_to_minify
                    # Unfortunately we cannot access the private property $minify_auto_js->files_to_minify so modify its
                    # shadow instead. We will need to correct this later.
                    if ( $script_tag_number !== count( self::$files_to_minify ) ) {
                        error_log( 'MC_Alt_W3TC_Minify Error: The shadow $files_to_minify is out of sync.[0]' );
                    }
                    self::$files_to_minify[$script_tag_number] = $filename;
                    # Remove this inline <script> element.
                    $data['should_replace'] = TRUE;
                    // TODO: 
                    $data['script_tag_new'] = "<!-- mc_w3tcm: inline start -->" . $data['script_tag_original'] . "<!-- mc_w3tcm: inline end -->\n";
                    // $data['script_tag_new'] = '';
                    if ( $monitor ) {
                        error_log( 'FILTER::w3tc_minify_js_do_local_script_minification():' );
                        self::print_r( self::$files_to_minify, 'self::$files_to_minify' );
                    }
                }
                return $data;
            } );
        }
        if ( self::non_short_circuit_or( self::$auto_minify,
                $monitor = ! empty( $options['FILTER::w3tc_minify_js_do_tag_minification'] ) ) ) {
            add_filter( 'w3tc_minify_js_do_tag_minification', function( $do_tag_minification, $script_tag, $file )
                    use ( $monitor ) {
                if ( $monitor ) {
                    error_log( 'FILTER::w3tc_minify_js_do_tag_minification():' );
                    self::print_r( $script_tag, '$script_tag' );
                    self::print_r( $file,       '$file' );
                }
                if ( self::$auto_minify ) {
                    # All non-inline scripts should pass through this filter so this is a good place to track them.
                    if ( $do_tag_minification ) {
                        # Update the $files_to_minify shadow.
                        self::$files_to_minify[] = $file;
                    } else {
                        # Update the $files_to_minify shadow with NULL to keep synchronization.
                        self::$files_to_minify[] = NULL;
                        // TODO:
                        // if $do_tag_minification == FALSE then this script is skipped and script order will be affected
                        error_log( "MC_Alt_W3TC_Minify Error: {$filename} skipped "
                                   . '- This will affect the script order which is not currently handled.' );
                    }
                    if ( $monitor ) {
                        error_log( 'FILTER::w3tc_minify_js_do_tag_minification():' );
                        self::print_r( self::$files_to_minify, 'self::$files_to_minify' );
                    }
                }
                return $do_tag_minification;
            }, PHP_INT_MAX, 3 );
        }
        if ( self::non_short_circuit_or( self::$auto_minify,
                $monitor = ! empty( $options['FILTER::w3tc_minify_js_do_flush_collected'] ) ) ) {
            add_filter( 'w3tc_minify_js_do_flush_collected', function( $do_flush_collected, $last_script_tag, $minify_auto_js )
                    use ( $monitor ) {
                if ( $monitor ) {
                    error_log( 'FILTER::w3tc_minify_js_do_flush_collected():' );
                    self::print_r( $last_script_tag, '$last_script_tag' );
                    self::print_r( $minify_auto_js,  '$minify_auto_js'  );
                }
                # $last_script_tag  === '' means all scripts have been processed i.e., essentially we are at </body>.
                if ( $last_script_tag !== '</head>' && $last_script_tag  !== '' ) {
                    # Logic for determining inline <script> elements extracted from Minify_AutoJs::process_script_tag().
                    $match = NULL;
                    if ( !preg_match( '~<script\s+[^<>]*src=["\']?([^"\'> ]+)["\'> ]~is', $last_script_tag, $match ) ) {
                        $match = NULL;
                    }
                    if ( $monitor ) {
                        self::print_r( is_null( $match ), 'is_null( $match )' );
                    }
                    if ( self::$auto_minify ) {
                        if ( is_null( $match ) ) {
                            # No src attribute so this is an inline <script> element.
                            // TODO:
                            // return FALSE;   # Prevent W3TC's Minify_AutoJs::flush_collected() from executing.
                            return TRUE;
                        }
                    }
                }
                # We are at '</head>' or at '</body>' so flush collected <script> elements.
                // TODO: replace W3TC's Minify_AutoJs::flush_collected() with self::flush_collected()
                // return FALSE;   # Prevent W3TC's Minify_AutoJs::flush_collected() from executing.
                return TRUE;
            }, 10, 3 );
        }
        if ( self::non_short_circuit_or( self::$auto_minify, $monitor = ! empty( $options['FILTER::w3tc_minify_js_step'] ) ) ) {
            add_filter( 'w3tc_minify_js_step', function( $data ) use ( $monitor ) {
                if ( $monitor ) {
                    error_log( 'FILTER::w3tc_minify_js_step():' );
                    self::print_r( $data, '$data' );
                }
                if ( self::$auto_minify ) {
                    // This filter provides an alternate way of preventing W3TC's Minify_AutoJs::flush_collected() from executing.
                    // This may be better than using the filter 'w3tc_minify_js_do_flush_collected' as it provides an additional
                    // opportunity for collecting data - $data['files_to_minify'].
                    // $data['files_to_minify'] = [];   # Prevent W3TC's Minify_AutoJs::flush_collected() from executing.
                    if ( array_diff( $data['files_to_minify'], self::$files_to_minify ) ) {
                        error_log( 'MC_Alt_W3TC_Minify Error: The shadow $files_to_minify is out of sync.[1]' );
                    }
                    if ( $monitor ) {
                        error_log( 'FILTER::w3tc_minify_js_step():' );
                        self::print_r( self::$files_to_minify, 'self::$files_to_minify' );
                    }
                }
                return $data;
            } );
        }
        if ( ! empty( $options['FILTER::w3tc_minify_js_step_script_to_embed'] ) ) {
            add_filter( 'w3tc_minify_js_step_script_to_embed', function( $data ) {
                error_log( 'FILTER::w3tc_minify_js_step_script_to_embed():' );
                self::print_r( $data, '$data' );
                return $data;
            } );
        }
        $monitor = ! empty( $options['FILTER::w3tc_minify_urls_for_minification_to_minify_filename'] );
        if ( self::$auto_minify || $monitor ) {
            add_filter( 'w3tc_minify_urls_for_minification_to_minify_filename', function( $minify_filename, $files, $type )
                    use ( $monitor ) {
                if ( $monitor ) {
                    error_log( 'FILTER::w3tc_minify_urls_for_minification_to_minify_filename():' );
                    self::print_r( $minify_filename, '$minify_filename' );
                    self::print_r( $files,           '$files'           );
                    self::print_r( $type,            '$type'            );
                    self::print_r( debug_backtrace( DEBUG_BACKTRACE_IGNORE_ARGS ), 'backtrace' );
                }
                if ( self::$auto_minify ) {
                    # save $minify_filename - the index to the array $minify_filenames as depending on the final solution we
                    # may need to adjust that item in the array $minify_filenames.
                    self::$minify_filename = $minify_filename;
                }
                return $minify_filename;
            }, 10, 3 );
        }
    }
    public static function set_monitor_minify_autojs_options($name, $value) {
        $options = get_option( self::OPTION_MONITOR_MINIFY_AUTOJS, [] );
        $options[ $name ] = $value;
        update_option( self::OPTION_MONITOR_MINIFY_AUTOJS, $options );
    }
    # non_short_circuit_or() implements an or where all conditions are always evaluated.
    # This is useful when the conditions have side effects.
    private static function non_short_circuit_or( ...$conditions ) {
        foreach ( $conditions as $condition ) {
            if ( $condition ) {
                return TRUE;
            }
        }
        return FALSE;
    }
    # This print_r() is necessary since the real print_r() uses output buffering and this causes the following error:
    #     PHP Fatal error:  print_r(): Cannot use output buffering in output buffering display handlers ...
    # when the real print_r() is used in some W3TC filters e.g. 'w3tc_minify_js_step' which are executed in output
    # buffering display handlers. N.B. this print_r() does not have the second boolean argument.
    public static function print_r( $var, $name = '' ) {
        static $tabs = '';
        $tabs .= '    ';
        $delim = '[';
        if ( is_object( $var ) ) {
            $class_name = get_class( $var );
            $var        = (array) $var;
            $delim      = '{';
        }
        if ( is_array( $var ) ) {
            error_log( "{$tabs}{$name} = " . ( $delim === '[' ? 'Array' : $class_name ) . '[' . sizeof( $var ) . "] = {$delim}" );
            foreach ( $var as $index => $value ) {
                if ( ! ctype_print( $index ) ) {
                    # Fix protected and private property names of objects
                    $index = str_replace( "\x0", '-', $index );
                }
                self::print_r( $value, "[$index]" );
            }
            error_log( "{$tabs}" . ( $delim === '{' ? '}' : ']' ) );
        } else {
            error_log( "{$tabs}{$name} = "
                . ( is_string( $var ) ? '(String[' . strlen($var) . "]) = \"{$var}\""
                                            . ( strpos( $var, "\n" ) !== FALSE ? ' = (String[' . strlen($var) . "]) = {$name}" : '' )
                                      : ( $var === NULL ? 'NULL'
                                                        : ( is_bool ( $var ) ? ( $var ? 'TRUE' : 'FALSE' )
                                                                             : "(Scalar) = {$var}" ) ) ) );
        }
        $tabs = substr( $tabs, 0, -4 );
    }
}
# Abort execution if the W3 Total Cache plugin is not activated.
if ( defined( 'WP_ADMIN' ) ) {
    add_action( 'admin_init', function() {
        if ( is_plugin_active( 'w3-total-cache/w3-total-cache.php' ) ) {
            MC_Alt_W3TC_Minify::admin_init();
        } else {
            add_action( 'admin_notices', function() {
    ?>
    <div class="notice notice-info is-dismissible">
        Execution of the W3TC Minify Helper plugin aborted because the required W3 Total Cache plugin is not activated.
    </div>
    <?php
            } );
        }
    } );
} else {
    add_action( 'wp_loaded', function() {
        include_once( ABSPATH . 'wp-admin/includes/plugin.php' );
        if ( is_plugin_active( 'w3-total-cache/w3-total-cache.php' ) ) {
            MC_Alt_W3TC_Minify::init();
        }
    } );
}
# Below for unit testing only.
if ( defined( 'WP_DEBUG' ) && WP_DEBUG && defined( 'MC_DEBUG' ) && MC_DEBUG ) {
    if ( ! defined( 'WP_ADMIN' ) ) {
        add_action( 'wp_loaded', function() {
            if ( ! is_plugin_active( 'w3-total-cache/w3-total-cache.php' )
                || \W3TC\Dispatcher::config()->get_boolean( 'minify.auto' ) ) {
                return;
            }
            $source0 = <<<EOD
function omega( alpha, beta ) {
    var gamma;
    gamma = alpha + beta;
    return gamma;
}
EOD;
            $source1 = <<<EOD
function omicron( alpha, beta ) {
    var gamma = 1;
    return = gamma * alpha * beta;
}
EOD;
            error_log( 'MC_Alt_W3TC_Minify::minify():$source0='          .  $source0 );
            error_log( 'MC_Alt_W3TC_Minify::minify():$source1='          .  $source1 );
            $minified = MC_Alt_W3TC_Minify::minify( [ $source0, $source1 ] );
            error_log( 'MC_Alt_W3TC_Minify::minify():$original_length=' . $minified['original_length'] );
            error_log( 'MC_Alt_W3TC_Minify::minify():$content='         . $minified['content'] );
            error_log( 'MC_Alt_W3TC_Minify::minify():$cache_id='        . $minified['cache_id'] );
            # Also verify that files have been created in ".../wp-content/cache/minify".
        } );
    }
}
